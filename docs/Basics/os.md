---
title: 操作系统笔记
date: 2021-01-08 18:05:01 GMT+0800
categories: [基础]
tags: []
---

## 用户态和内核态

- 许多操作系统将内存分为内核空间与用户空间
- 进程可以创建用户态线程和内核态线程
  - 用户态线程：由主线程自己维护，不参与操作系统调度，无法利用多核
  - 内核态线程：创建成本高，IO 不需要系统调用，阻塞后可以由操作系统切换线程
- 用户态线程映射内核态线程
  - 多对一：全是用户态线程，只能用一个核，同一时间只有一个线程在运行
  - 一对一
  - 多对多（n:m）：m 通常设置为核数
  - 两层设计：大多线程使用多对多，少数线程使用一对一

## 中断

- **同步中断**是 CPU 主动触发的中断
  - **陷阱**：从用户态切换到内核态
  - **错误**：缺页中断
  - **异常**：程序抛出异常
- **异步中断**是响应外部设备触发的中断，比如键盘输入
- **可屏蔽中断**是可以被忽略的中断如果中断寄存器置为 1，比如键盘输入
- **不可屏蔽中断**是不可忽略的中断即使中断寄存器置为 1，比如掉电中断

::: tip JS 如何响应中断
用户按下键盘 -> 键盘芯片发送电信号 -> 总线通知 CPU -> 触发 CPU 中断 -> 根据中断类型计算中断向量表偏移 -> 执行跳转指令 -> PC 指针指向中断向量表指向的代码 -> 执行操作系统的代码 -> 触发 JS 调用的操作系统 API

补充：
开机时 BIOS 向中断向量表中填充地址，以便响应用户的键盘输入。操作系统启动时会覆盖中断向量表指向自己的代码。
:::

## 进程与线程

### 线程的状态

- **就绪**：线程排队中
- **运行**：线程运行中
- **阻塞**：线程在**运行**中由于 IO 阻塞，操作系统将其置为阻塞状态，等到 IO 加载完成通过中断通知 CPU 将线程置为**就绪**状态

### 进程表与线程表

- 进程表
  - 描述信息：PID、进程名称、所属用户
  - 资源信息：虚拟内存映射、文件、IO 设备
  - 内存布局
- 线程表
  - ThreadID、状态、优先级、程序计数器、寄存器的值

### 上下文切换

#### 线程切换

同一进程的不同线程间的切换需要保存上一线程的私有数据（栈、寄存器）等数据，并加载下一线程的私有数据。

#### 进程切换

除了保存线程数据，还要保存进程的虚拟内存、全局变量。

> 系统调用导致的中断切换是同一进程从用户态到内核态，仅保存栈、寄存器，不保存虚拟内存。

::: tip 性能分析
可以通过`vmstat`、`pidstat`等工具排查上下文切换问题。

**自愿上下文切换**：进程因为无法获得资源主动发起的调度
**非资源上下文切换**：进程因为时间片到了，被操作系统强制发起的调度
:::

**自愿上下文切换**

### 线程调度

- 先到先服务：没有饥饿，但作业的拖延时间可能很长
- 短作业优先：平均等待时间最短，但可能饥饿
- 优先级队列：任务本身优先级、任务预估执行时间、任务等待时间共同决定优先级
- 时间片：每个线程运行一段时间后被下一线程抢占并循环
- 多级队列：外层数组的优先级由大到小，CPU 优先执行高优先级的队列，同级的队列通过时间片策略进行调度，如果经过一段时间任务还没有完成，说明是个长任务，将它加入到低一级优先级队列。

### 进程间通信

#### 管道

```sh
process 1 | process 2 | process 3
# or
process 1 > namedpipe
process 2 > namedpipe
```

::: tip
进程并不能感知到管道的存在，所以管道的方式是非侵入式的。
:::

#### 本地内存共享

Linux 采用虚拟文件系统实现，看似操作文件，实际操作内存，程序需要操作 API 以及处理同步问题，是侵入式的，不是高性能场景较少使用。

#### 本地消息/队列

Unix 可以使用 POSIX 标准的 mqueue 或者使用 TCP/IP 协议实现消息的收发。

## 锁

### CAS（compare and swap）

这是 CPU 实现的原子操作，如果指定地址的值不等于预期值返回`false`，否则更新为目标值并返回`true`

```cpp
bool cas(&oldValue, expectedValue, targetValue)
```

:::

保证`i++`完成：

```cpp
while(!cas(&i,i,i+1)){}
```

:::

### TAS（test and set）

少数 CPU 没有提供 CAS 只有简单的 TAS，TAS 就是特殊版的 CAS：

```cpp
tas(&lock) {
  return cas(&lock, 0, 1)
}
```

### 锁的基本实现

实现`lock()`与`unlock()`：

```cpp
int lock = 0;

lock() {
  while(!tas(&lock)){}
}

leave() {
  lock = 0
}
```

::: tip
自旋锁，如果没有抢到锁会一直占用 CPU 资源。可以在`lock()`内的`while`循环体内加入`wait()`，如果没有抢到锁就让出 CPU。
:::

### 信号量

允许 N 个线程进入临界区：

```cpp
up(&lock){
  while(!cas(&lock, lock, lock+1)) { }
}
down(&lock){
  while(!cas(&lock, lock, lock - 1) || lock == 0){}
}

int lock = N;
down(&lock);
// 临界区
up(&lock);
```

### 分布式锁

单机环境中通过 CPU 的 CAS 指令实现锁，在分布式中可以通过工具的原子操作实现分布式锁，比如 redis 的 setnx 指令、Zookeeper 的节点操作。

### 死锁

4 个基本条件：

- **资源互斥**：资源只能供一个线程使用
- **持有等待**：没有请求到资源不释放已占有资源
- **不可抢占**：资源只能由线程主动释放
- **循环等待**：若干线程首尾相接形成环状

## 虚拟内存

### Swap

一部分进程使用内存，一部分不使用。不使用内存的进程将数据保存到磁盘上，当需要使用时将磁盘的数据读到内存，如果内存不够，就把其它进程的内存占用写到磁盘。但存在频繁切换以及内存碎片等问题。

#### 页

**页**不仅解决了碎片问题，还可以让操作系统不关注哪个进程是高频的，只关注哪些页是高频的。

虚拟内存的每个小块成为 **Page**，真实内存的每个小块成为 **Frame**，Page 到 Frame 的映射成为**页表**。如果进程需要的内存较大，页表本身都会占用非常大的内存，并且其中只有少数条目有对应的 Param（为了能在 **O(1)** 时间内找到条目，所以需要连续的 Page Number 即使没有对应的 Param），所以需要**多级页表**。虚拟地址的前两位即 Page Directory 的偏移，得到 Page Table 的编号，找到该编号的 Page Table 并偏移虚拟地址的中间部分得到 Param Number。

::: tip
CPU 中有个 MMU（Memory Management Unit）负责完成虚拟地址到物理地址的转换并读取内存，MMU 中还有一个 TLB（Translation Lookaside Buffer），也称为快表，目标是缓存 Page Number 与 Frame Number 的映射关系，即每个缓存行存储了 Page Number 与 Frame Number。

缓存方案：

- **直接映射**：`缓存行号 = Page Number % 64`，缺点是有些缓存行没有使用，而有些缓存行出现哈希冲突导致缓存 miss。
- **n 路组相联映射**：类似哈希表的开放寻址法，当出现冲突时，允许向后查询几行空闲缓存行，以充分利用缓存行。

通常的页大小是 4K，当应用对内存需求较大时，可以考虑开启大内存分页 4M，这样可以只使用一级缓存，TLB 也可以减小哈希冲突，增加缓存命中。

:::
