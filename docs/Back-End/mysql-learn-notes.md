---
title: MySQL 学习笔记
date: 2022-10-18 14:25:07 GMT+0800
categories: [后端]
tags: [MySQL]
---

::: abstract
最近在学习 MySQL，记录一些学习笔记。
:::

<!-- more -->

## 索引

### B+ 树索引

**主键索引**: 叶子结点是整行数据

**非主键索引**: 叶子结点是主键

::: tip

- 通过非主键索引查询整行数据时，需要先通过索引拿到命中的主键，再通过主键索引找到整行数据（即回表）
- 通过索引查部分列时，如果部分列也在该索引中，那么可以直接查到，不需要回表（覆盖索引）
- 主键长度越长，普通索引的叶子结点越大，占用的存储空间越大
- 在主键索引“中间”插入或删除可能会移动大量数据

:::

**联合索引**: 列（a,b,c）按顺序拼接起来作为一个索引

::: tip

- 最左前缀原则：联合索引的查询条件，必须从最左边开始，否则无法使用索引
- 索引下推优化：MySQL 5.6 引入，假如有个查询`WHERE a BETWEEN 1 AND 10 AND c = 5`，因为查询条件是（a，c），所以只有 a 条件能走联合索引，找到满足 a 条件的索引时，判断这条索引的 c 的值是否等于 5，如果等于 5 才去回表查数据。（此版本前，拿到满足 a 条件的索引会直接回表查 c 条件是否满足）
- **待确认**：假如有个表，有主键 a 和普通索引 b，因为普通索引的叶子结点是主键 a，所以这个普通索引也可以近似理解成（b，a）联合索引

:::

## 锁

InnoDB 支持行锁、表锁、全局锁，行锁是默认的锁类型，表锁需要手动指定。MyISAM 不支持行锁。

在一个事务里，在 SQL 语句执行前，会先获取锁，执行完后不释放锁，等事务提交才释放。所以需要业务对一次事务内的 SQL 排序，最好把影响较大的 SQL 放到后面，减少锁等待时间。

**死锁**：假如有两个事务，事务 A 拿到 id=1 的行锁，请求 id=2 的行锁，事务 B 拿到 id=2 的行锁，请求 id=1 的行锁，这时就会产生死锁。

::: tip 两种方案

1. 等待超时，释放锁
2. 开启死锁检测逻辑，检测到死锁后，回滚其中一个事务，但需要耗费 CPU 资源（可以通过控制并发度减缓）

:::

## Change Buffer

数据库更新时，如果数据页在内存中，可以直接写入内存。如果不在内存中，则可以将此更新记录到 Change Buffer。

数据库有线程会定期将 Change Buffer 保存的所有改动应用到原数据。

查询数据时，如果 Change Buffer 有相关的更新记录，需要 merge 到查询结果中。

::: tip

- 只有普通索引才能用上 Change Buffer，唯一索引不行，因为唯一索引在更新时需要判断唯一性约束是否满足，需要将原数据加载到内存，此时可以直接在内存中更新
- 如果业务上每次更新后都需要查一遍原数据，应关闭 Change Buffer，这样的话数据库会将数据加载进内存并改动，方便后续查询。

:::
