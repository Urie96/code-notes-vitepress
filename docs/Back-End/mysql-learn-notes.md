---
title: MySQL 学习笔记
date: 2022-10-18 14:25:07 GMT+0800
categories: [后端]
tags: [MySQL]
---

::: abstract
最近在学习 MySQL，记录一些学习笔记。
:::

<!-- more -->

## 索引

### B 树

- 树高比较矮（通常不会超过 4 层），减少频繁的磁盘 IO 访问时间。
- 节点根据 key 大小有序排列，方便范围查询。
- 上层的指针指向一个大节点，一个大节点由多个小节点组成。每个大节点大小不超过一个页且按页对齐，便于读取到内存。

### InnoDB B+ 树索引

B 树的变种：只有最底层的叶子节点存储 data，上层的节点只存储 key（B 树会在上层的节点存储 data），每页可以存储更多的 key。

另外，数据库的 B+树还有这样的优化：最底层的叶子节点还维护了到下一叶子节点的 next 指针，便于区间查询数据。

**主键索引**: 叶子节点 data 是整行数据

**非主键索引**: 叶子节点 data 是主键（为什么 data 不像 MyISAM 一样存整行数据的地址？便于覆盖索引直接拿主键）

::: tip

- 通过非主键索引查询整行数据时，需要先通过索引拿到命中的主键，再通过主键索引找到整行数据（即回表）
- 通过索引查部分列时，如果部分列也在该索引中，那么可以直接查到，不需要回表（覆盖索引）
- 主键长度越长，普通索引的叶子节点越大，占用的存储空间越大
- 在主键索引“中间”插入或删除可能会移动大量数据

:::

**联合索引**: 列（a,b,c）按顺序拼接起来作为一个索引

::: tip

- 最左前缀原则：联合索引的查询条件，必须从最左边开始，否则无法使用索引
- 索引下推优化：MySQL 5.6 引入，假如有个查询`WHERE a BETWEEN 1 AND 10 AND c = 5`，因为查询条件是（a，c），所以只有 a 条件能走联合索引，找到满足 a 条件的索引时，判断这条索引的 c 的值是否等于 5，如果等于 5 才去回表查数据。（此版本前，拿到满足 a 条件的索引会直接回表查 c 条件是否满足）
- 索引选择性：`COUNT(DISTINCT(a)) / COUNT(*)`，选择性越高则建索引的收益越大（因为可以过滤掉非常多的行）。如果索引 a 的选择性太低，（a,b）的选择性很高但索引长度太长，可以考虑建立索引（a,func(b)），保证既有较高的选择性且索引长度也不太长。

:::

## 锁

InnoDB 支持行锁、表锁、全局锁，行锁是默认的锁类型，表锁需要手动指定。MyISAM 不支持行锁。

在一个事务里，在 SQL 语句执行前，会先获取锁，执行完后不释放锁，等事务提交才释放。所以需要业务对一次事务内的 SQL 排序，最好把影响较大的 SQL 放到后面，减少锁等待时间。

**死锁**：假如有两个事务，事务 A 拿到 id=1 的行锁，请求 id=2 的行锁，事务 B 拿到 id=2 的行锁，请求 id=1 的行锁，这时就会产生死锁。

::: tip 两种方案

1. 等待超时，释放锁
2. 开启死锁检测逻辑，检测到死锁后，回滚其中一个事务，但需要耗费 CPU 资源（可以通过控制并发度减缓）

:::

## Change Buffer

数据库更新时，如果数据页在内存中，可以直接写入内存。如果不在内存中，则可以将此更新记录到 Change Buffer。

数据库有线程会定期将 Change Buffer 保存的所有改动应用到原数据。

查询数据时，如果 Change Buffer 有相关的更新记录，需要 merge 到查询结果中。

::: tip

- 只有普通索引才能用上 Change Buffer，唯一索引不行，因为唯一索引在更新时需要判断唯一性约束是否满足，需要将原数据加载到内存，此时可以直接在内存中更新
- 如果业务上每次更新后都需要查一遍原数据，应关闭 Change Buffer，这样的话数据库会将数据加载进内存并改动，方便后续查询。

:::
