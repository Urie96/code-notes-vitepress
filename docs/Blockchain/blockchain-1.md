---
title: 区块链入门(一)：技术简介
date: 2022-07-22 13:13:18 GMT+0800
categories: [区块链]
tags: [BlockChain, Ethereum]
---

::: tip
区块链技术的实现主要包括分布式网络、共识机制、加密算法、账户与存储模型四部分。
:::

<!-- more -->

## P2P 分布式网络

### 种子下载

1. 下载.torrent 种子文件，解析出其中的 tracker URL 和文件信息
2. 连接 tracker 服务器部分获取下载者的 ip，并递归地从下载者处获取其他下载者的 ip
3. 将待下载文件视为多个块，从其他下载者处获取自己尚未下载的块，并向其他下载者分享自己已下载的块
4. 每下载一个块，计算该块的 hash，与种子文件中存储的该块的 hash 进行比较，判断块内容的准确性

### 比特币网络

P2P 网络拓扑结构有很多种，有些是中心化拓扑，有些是半中心化拓扑，有些是全分布式拓扑结构。比特币全节点组成的网络是一种全分布式的拓扑结构，节点与节点之间的传输过程更接近“泛洪算法”，即：交易从某个节点产生，接着广播到临近节点，临近节点一传十十传百，直至传播到全网。

- 发现节点：通过请求社区维护的域名（比如`seed.bitcoin.sipa.be:8333`，能解析出二十几个 ip）获取其他部分节点 ip，并获取其他节点所维护的对等节点。
  > 这是比特币发现节点的方式，从部分域名处查询对等节点不太符合去中心化的理念。所以以太坊采用了 DHT（Distributed Hash Table）来定位资源。
- 内网穿透：NAT 可以将**公有 ip:port**映射为**私有 ip:port**；UPnP 用于设备的互联互通

## 账户模型

普通应用的账户模型通常是账户余额模型，即系统存储了每个账户的余额，当发起一次交易时，会先扣除付款人的余额，再增加收款人的余额。在同一数据库中这个操作可以使用事务非常方便地进行处理。但如果是跨系统转账则需要自己实现事务机制，中途失败则需要手动冲正之前的操作。

### UTXO 账户模型（以比特币为例）

> UTXO：Unspent Transaction Output

#### 一个场景

![一个例子](https://cdn.jsdelivr.net/gh/Urie96/images/20220722132443.jpg)

- 比特币不保存账户余额；每一次交易，记录的是动作，而不是余额变动
- 如果需要获取账户的余额，则需要从创始区块开始回放所有交易，实时计算余额
- 一个交易可以有多个输入及多个输出，每个输入会指向一个或者多个（凑够需要的输入金额为止）其他已完成交易的输出上（即未花费的交易输出）
- 交易可以设置交易费，交易费高的会被矿工优先打包

#### 交易的数据结构（为了方便理解才用的 json）

```json
{
  "版本": 0,
  "交易输入": [
    {
      "输入指针": 0, // 指向花费掉的UTXO
      "解锁脚本": "" // 货币持有者的签名
    }
  ],
  "交易输出": [
    {
      "交易总聪数": 0,
      "锁定脚本": ""
    }
  ],
  "时间戳": 0
}
```

#### 区块

用户发起交易，请求打到某个节点，节点验证此交易有效性后广播到全网。矿工可选择一些交易打包成区块（需要共识机制选出打包人），再将区块传播至全网。

::: tip 区块分叉
在较低概率的情况下，南极和北极两个矿工同时挖矿成功，并广播自己打包的区块，那全网节点都会先后收到两个区块。假如南半球节点先收到了南极节点打包的区块，北半球节点先收到了北极节点打包的区块，则南半球节点将南极节点的区块作为主区块，将北极节点作为分叉区块。
接着继续打包下一区块，各矿工以本地的主区块作为父区块。假如第二次是北半球的节点先打包成功，传播至全网后，南半球的节点发现分叉区块比主区块长，则会将分叉区块作为主区块。
:::

#### 区块的数据结构

```json
{
  "区块头": {
    "父区块哈希值": "", // 通过此字段链到父区块，如果想篡改某区块，子区块全都会变
    "默克尔根值": "", // 将交易两两求哈希，递归，最后得到一个哈希，可根据此值快速判断该区块是否包含某区块
    "难度目标值": 0,
    "Nonce": 0
  },
  "交易数据": [] // 区块内存储的所有交易，不会低于500条
}
```

## 加密算法

::: tip 三大类算法

1. 哈希算法：没有密钥，但不可通过哈希值获取原文，如 md5，SHA 算法
2. 对称加密算法：明文通过密钥加密成密文，密文可以使用同样的密钥解密成明文，如 DES、AES
3. 非对称加密：明文通过私钥加密成密文，密文通过公钥解密成明文，如 RSA、ECC

:::

### 非对称加密算法

区块链中的一个钱包地址可以看成是一个账户，为了防止别人冒充我们的身份私自转账，所有节点需要一种加密算法来验证交易是否是“真正”的付款人发起的。

区块链交易采用椭圆曲线数字签名算法(ECDSA)，用户创建账户时保存私钥，私钥通过算法生成公钥，公钥通过一系列算法生成钱包地址。交易时通过私钥将交易数据加密，然后广播到全网，任何节点都可以通过钱包地址解密，解密成功说明该交易确实是由付款人发起的。

<div align=center>
<img src="https://cdn.jsdelivr.net/gh/Urie96/images/20220722134427.jpg"/>
</div>

## 共识机制

区块链是一个分布式系统，分布式系统最重要最基本的问题就是一致性问题，即任意节点的提案能够在约定的协议下被其他所有节点所认可。

区块链由于采用的是分布式网络，各个节点互不信任，所以共识机制还需要解决在广播过程中中继节点篡改数据，这种情况被称为拜占庭错误。经典的分布式一致性算法如 Raft、Paxos 协议均不提供拜占庭容错。

区块链的共识算法的整体思路就是让攻击者的攻击成本远远大于收益。目前比较成熟的包括 PoW（proof of work），PoS 和 DPoS。

### 工作量证明 PoW

PoW 机制是一种设计思路，而不是一种具体实现。发送者需要计算一个按照规则约定难题的答案，发送给接受者的同时，需要附带验证这个答案，如果接收者验证这个答案有效，才会接受这个消息。

早期为了防止垃圾邮件泛滥，曾使用过下图这种方式：发送者发送邮件前，需要将整个邮件内容与一个**随机数**放一起计算哈希值，只有当哈希值的前 n 位均为 0 才能发送。由于哈希不可逆向计算，所以 CPU 需要尝试大量不同的随机数才能满足条件。接收者收到邮件时，判断满足条件才会接收。(如下图)

![alt](https://cdn.jsdelivr.net/gh/Urie96/images/20220722134808.jpg)

::: tip 比特币挖矿
挖矿：尝试不同的 Nonce 值，使`SHA256(SHA256(区块头))<难度目标值`

随着计算速度提升，为了控制出块速度始终保持大概在 10 分钟/个，每过 2016 个区块后，各节点根据这些区块的出块时间重新调整难度目标值
:::
